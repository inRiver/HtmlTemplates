<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Specification Import Export</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.15.1/moment.min.js"></script>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/js/bootstrap-multiselect.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/css/bootstrap-multiselect.css" type="text/css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datetimepicker/4.7.14/js/bootstrap-datetimepicker.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datetimepicker/4.7.14/css/bootstrap-datetimepicker.min.css">


    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.2.1/jstree.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.2.1/themes/default/style.min.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore.js"></script>

    <script type="text/javascript" src="https://unpkg.com/xlsx/dist/shim.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>

    <style type="text/css">
        table {
            font-family: arial, sans-serif;
            border-collapse: collapse;
            width: 100%;
        }

        td, th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        #fieldtypeselection > ul {
            list-style-type: none;
            column-count: 3;
        }

            #fieldtypeselection > ul li {
                position: relative;
            }

                #fieldtypeselection > ul li > ul {
                    top: -12px;
                    left: 190px;
                    position: absolute;
                    visibility: hidden;
                    z-index: 1;
                    background: #ffffff;
                    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25);
                    list-style: none;
                    width: 190px;
                    padding: 10px 0;
                    font-size: 14px;
                    line-height: 16px;
                    letter-spacing: .02em;
                }

        input[type=text] {
            width: 100%;
        }

        input:invalid {
            border-color: red;
        }

        input, input:valid {
            border-color: #ccc;
        }

        .invalidTextarea {
            border-color: red;
            border-width: 2px;
        }

        .buttonInvalidForInput {
            cursor: not-allowed;
            pointer-events: none;
            /*Button disabled - CSS color class*/
            color: #c0c0c0;
            background-color: #ffffff;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #555;
            width: 24px;
            height: 24px;
            -webkit-animation: spin 2s linear infinite; /* Safari */
            animation: spin 2s linear infinite;
        }

        .optionGroup {
            font-weight: bold;
            font-style: italic;
        }

        .failed {
            color: red;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>

    <script>
        //BELOW IS CODE TO THROTTLE THE NUMBER OF AJAX REQUEST SO WE DO NOT GET STOPPED BY THE API.

        /**
         * ajaxthrottle.js
         *
         * Usage:
         *
         *     var t = $.ajaxthrottle({
         *        numRequestsPerTimePeriod : N,
         *        timePeriod               : P,
         *        maxConcurrent            : M
         *     });
         *
         *     t.ajax(args);
         *
         * This is just like calling $.ajax(args), except that requests are throttled
         * so that no more than N are initiated in any time period of P milliseconds,
         * and no more than M concurrent (outstanding at the same time) requests are allowed.
         * If N or P is 0, there is no time period based constraint, and if M is 0, there
         * is no constraint on the number of concurrent requests.
         *
         * Mark Phillips <mphillip@unca.edu>
         * Thu Dec 20 11:04:19 2012
         */
        (function ($) {
            $.ajaxthrottle = function (options) {

                var timeout,

                    settings = $.extend({
                        numRequestsPerTimePeriod: 0,
                        timePeriod: 0,
                        maxConcurrent: 9
                    }, options),

                    time = function () {
                        return (new Date()).getTime();
                    },

                    // Array of outstanding requests; these are requests that have
                    // been initiated with a call to $.ajax() but that have not
                    // completed yet.  Each entry in this array is an object of the form
                    //    {
                    //         arguments: the original arguments list passed to .ajax()
                    //              time: the time this request was passed to $.ajax()
                    //          deferred: the jQuery deferred object for this request
                    //    }
                    outstanding_reqs = [],

                    // Array of initiated requests; each entry in this array
                    // is an object just like the ones in the outstanding_reqs
                    // array above, but this array keeps track of all
                    // requests, regardless of whether they have completed.
                    // This list is used to keep track of how many requests
                    // have been initiated in settings.timePeriod.  Requests
                    // that are older than settings.timePeriod milliseconds
                    // get removed from this list when it is purged.
                    initiated_reqs = [],

                    // Array of requests waiting to be initiated
                    waiting_reqs = [],

                    // Purge the initiated reqs list so that it doesn't contain any
                    // reqs from more than settings.timePeriod ms ago.  Return the
                    // amount of time that needs to be waited until the oldest remaining
                    // (after purging) req in the list will be settings.timePeriod ms old.
                    // Do all of this relative to the passed in 'now' value.
                    purge_initiated_reqs = function (now) {
                        if (settings.timePeriod >= 0) {
                            while ((initiated_reqs.length > 0)
                                &&
                                (initiated_reqs[0].time + settings.timePeriod - now <= 0)) {
                                initiated_reqs.shift();
                            }
                            if (initiated_reqs.length > 0) {
                                return initiated_reqs[0].time + settings.timePeriod - now;
                            }
                        }
                        return 0;
                    },

                    // remove a req from the outstanding_reqs list
                    remove_outstanding_req = function (obj) {
                        $.each(outstanding_reqs, function (i) {
                            if (outstanding_reqs[i] === obj) {
                                outstanding_reqs.splice(i, 1);
                                return false;
                            }
                            return true;
                        });
                    },

                    // Initiate the next request on the waiting list, unless we need to wait
                    // till some time has passed or some outstanding requests have completed.
                    process_waiting = function () {
                        var now = time(),
                            delay, req, deferred;

                        if (waiting_reqs.length <= 0) {
                            return;
                        }

                        delay = purge_initiated_reqs(now);

                        // If we have a timePeriod constraint, and the max number of allowed
                        // requests have gone out in that time period, arrange to wait for
                        // 'delay' ms
                        if ((settings.numRequestsPerTimePeriod > 0) && (settings.timePeriod > 0)
                            &&
                            (delay > 0)
                            &&
                            (initiated_reqs.length >= settings.numRequestsPerTimePeriod)) {
                            // clear any existing timeout first, because this one will
                            // require waiting till after it would finish anyway
                            if (timeout !== undefined) {
                                clearTimeout(timeout);
                            }
                            timeout = setTimeout(function () {
                                timeout = undefined;
                                process_waiting();
                            }, delay);
                            return;
                        }

                        // If the max number of allowed requests is outstanding, do nothing;
                        // process_waiting() will get called again when a request completes.
                        if ((settings.maxConcurrent > 0)
                            &&
                            (outstanding_reqs.length >= settings.maxConcurrent)) {
                            return;
                        }

                        // If we make it to here, then it's OK to initiate the next
                        // request in the waiting list
                        req = waiting_reqs.shift();
                        req.time = time();
                        initiated_reqs.push(req);
                        outstanding_reqs.push(req);
                        $.ajax.apply($, req.arguments).done(function () {
                            req.deferred.resolve.apply(req.deferred, arguments);
                        }).fail(function () {
                            req.deferred.reject.apply(req.deferred, arguments);
                        }).always(function () {
                            remove_outstanding_req(req);
                            process_waiting();
                        });

                    }
                    ;

                return {
                    ajax: function () {
                        var deferred = $.Deferred();
                        waiting_reqs.push({ arguments: arguments, deferred: deferred });
                        process_waiting();
                        return deferred.promise();
                    }
                };
            };
        }(jQuery));

        //SETUP THROTTLE SO WE MAX DO 9 CONCURRENT REQUEST ELSE WE WILL GET BLOCKED BY THE REST API.
        var throttle = $.ajaxthrottle({
            numRequestsPerTimePeriod: 0,
            timePeriod: 0,
            maxConcurrent: 9
        });
        //t.ajax(args);
    </script>

    <script type="text/javascript">
        //THIS NEED TO BE UPDATED FOR THE SPECIFIC ENVIRONMENT
        var apikey = "391a8bdc903bafb080a12ff756edf0b7";
        var language = "en";
        var baseurl = "https://apieuw.productmarketingcloud.com/api/v1.0.0/";

        var specificationTypeId = "Specification";
        var chunkSize = 1000;

        var foundEntities;
        var workareasarray;
        var specificationFieldsArray;
        var allCvls = [];
        var specificationLinkTypes;
        var selectedSpecificationId;
        var specificationLinkTypeIds = "ProductSpecifications,Item2SpecificationCorrect";
        var allLanguages;
        var showDataType = false;
        var specifications = new Object();
        var csvDivider;
        var cvlSeparator;
        var specificationMainNameField = 'SpecificationName';

        var predefinedColumns = [
            {
                columnName: "EntityId", exportOperation: function (entity) {
                    return entity.entityId;
                }
            },
            {
                columnName: "SpecificationName", exportOperation: function (entity) {
                    return specifications[selectedSpecificationId].specificationName;
                }
            }
        ];
        var validations = {
            "Integer": function (value) {
                var exp = /^([+-]?[0-9]*)$/.test(value);
                console.log("Integer: " + value + ", exp: " + exp);
                return exp;
            },
            "Double": function (value) {
                var exp = /^([1-9]\d*(\.|\,)\d*|0?(\.|\,)\d*[1-9]\d*|[1-9]\d*)$/gm.test(value);
                console.log("Double: " + value + ", exp: " + exp);
                return exp;
            },
            "DateTime": function (value) {
                var exp = /^(\d{4})(-(\d{2}))??(-(\d{2}))??(T(\d{2}):(\d{2})(:(\d{2}))??(\.(\d+))??(([\+\-]{1}\d{2}:\d{2})|Z)??)??$/.test(value);
                console.log("DateTime: " + value + ", exp: " + exp);
                return exp;
            }
        };

        window.onload = function () {
            fetchAllOutboundSpecificationLinkTypeIds();
            fetchworkareas();
            fetchAllCvls();
            fetchAllLanguages();
            hideSpecificationTemplate();

            $("#tabs").tabs();

            var xlf = document.getElementById('doImport');
            if (!xlf.addEventListener) return;
            function handleFile(e) { doImport(e.target.files); }
            xlf.addEventListener('change', handleFile, false);

            setCsvDivider();
        }

        function setCsvDivider() {
            var divider = "";
            var csvDividerSelection = document.getElementsByName("csvDividerSelect");
            for (var i = 0; i < csvDividerSelection.length; ++i) {
                if (csvDividerSelection[i].checked || csvDividerSelection.length === 1) {
                    divider = csvDividerSelection[i].value;
                    break;
                }
            }

            if (divider === "comma") {
                csvDivider = ',';
            } else {
                csvDivider = ';';
            }

            toggleCvlSeparator();

            console.log('setCsvDivider: ' + csvDivider);
        }

        function toggleCvlSeparator()
        {
            if (csvDivider === ',') {
                cvlSeparator = ';';
            } else {
                cvlSeparator = ',';
            }

        }

        function fetchworkareas() {
            $.ajax({
                type: "GET",
                dataType: "json",
                contentType: 'application/json',
                beforeSend: function (request) {
                    request.setRequestHeader("X-inRiver-APIKey", apikey);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader("Accept-Language", language);

                }, // GET /api/v1.0.0/workareafoldertree
                url: baseurl + "workareafoldertree?includeCreatedByMe=false",
                processData: false,
                success: function (workareas) {
                    console.log("Success");
                    console.log(workareas);
                    console.log(workareas);
                    workareasarray = workareas;
                    console.log(workareasarray.length);
                }, error: function (xhr) {
                    console.log("Error occured.please try again");
                },
                complete: function () {
                    var workareasselectorhtml = '<div id="workareaselector">';
                    workareasselectorhtml += '<ul>';
                    workareasselectorhtml += '<li id="topLevel" value="none">Common Shared';
                    workareasselectorhtml += '<ul>';
                    for (var i = 0; i < workareasarray.length; i++) {
                        if (workareasarray[i].folders !== undefined) {
                            workareasselectorhtml += renderWorkareaSubLevels(workareasarray[i]);
                        }
                        else {
                            workareasselectorhtml += '<li value="' + workareasarray[i].id + '" >' + workareasarray[i].name + '</li>';
                        }
                    }
                    workareasselectorhtml += "</li>";
                    workareasselectorhtml += "</ul>";
                    workareasselectorhtml += "</ul>";
                    workareasselectorhtml += "</div>";

                    document.getElementById("workareaselection").innerHTML = workareasselectorhtml;

                    $('#workareaselector').jstree({
                        'plugins': ["wholerow", "types"]
                    });
                    $('#workareaselector').jstree("open_node", $('#topLevel'));

                    $('#workareaselector').on("changed.jstree", function (e, data) {
                        console.log(data.node.li_attr.value);
                        fetchspecifications(data.node.li_attr.value);
                    });
                }
            });
        }

        function renderWorkareaSubLevels(workarea) {
            var workareasselectorhtml = '<li value="' + workarea.id + '">' + workarea.name;
            workareasselectorhtml += '<ul>';
            for (var j = 0; j < workarea.folders.length; j++) {
                if (workarea.folders[j].folders !== undefined) {
                    workareasselectorhtml += renderWorkareaSubLevels(workarea.folders[j]);
                } else {
                    workareasselectorhtml += '<li value="' + workarea.folders[j].id + '" >' + workarea.folders[j].name + '</li>';
                }
            }
            workareasselectorhtml += "</ul>";
            workareasselectorhtml += "</li>";

            return workareasselectorhtml;
        }

        function fetchAllCvls() {
            $.ajax({
                type: "GET",
                dataType: "json",
                contentType: 'application/json',
                beforeSend: function (request) {
                    request.setRequestHeader("X-inRiver-APIKey", apikey);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader("Accept-Language", language);

                },
                url: baseurl + "model/cvls",
                processData: false,
                success: function (cvls) {
                    cvls.forEach(function (item, index) {
                        var cvlWithValues = item;
                        cvlWithValues.values = [];
                        allCvls.push(cvlWithValues);
                    });
                },
                error: function (xhr) {
                    console.log("Error occured.please try again");
                }
            });
        }

        function fetchAllLanguages() {
            $.ajax({
                type: "GET",
                dataType: "json",
                contentType: 'application/json',
                beforeSend: function (request) {
                    request.setRequestHeader("X-inRiver-APIKey", apikey);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader("Accept-Language", language);

                },
                url: baseurl + "model/languages",
                processData: false,
                success: function (languages) {
                    allLanguages = languages;
                    console.log(allLanguages);
                },
                error: function (xhr) {
                    console.log("Error occured.please try again");
                }
            });
        }

        function fetchAllOutboundSpecificationLinkTypeIds() {
            specificationLinkTypeIds = "";
            $.ajax({
                type: "GET",
                dataType: "json",
                contentType: 'application/json',
                beforeSend: function (request) {
                    request.setRequestHeader("X-inRiver-APIKey", apikey);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader("Accept-Language", language);

                }, // GET /api/v1.0.0/model/entitytypes
                url: baseurl + "model/entitytypes",
                processData: false,
                success: function (entityTypes) {
                    var specification = entityTypes.find(function (entityType) {
                        return entityType.id === specificationTypeId;
                    });
                    var delimiter = "";
                    specification.inboundLinkTypes.forEach(function (linkType, index) {
                        specificationLinkTypeIds += delimiter + linkType;
                        delimiter = ",";
                    });
                    console.log(specificationLinkTypeIds);

                    specificationMainNameField = specification.displayNameFieldTypeId;
                },
                error: function (xhr) {
                    console.log("Error occured.please try again");
                }
            });

        }

        function getCvlValues(cvlId) {
            var cvl = allCvls.find(function (cvl) {
                return cvl.id === cvlId;
            });
            console.log("Found cvl for cvlId = " + cvlId);
            console.log(cvl);
            if (cvl.values.length === 0) {
                $.ajax({
                    type: "GET",
                    dataType: "json",
                    contentType: 'application/json',
                    beforeSend: function (request) {
                        request.setRequestHeader("X-inRiver-APIKey", apikey);
                        request.setRequestHeader("Accept", "application/json");
                        request.setRequestHeader("Accept-Language", language);

                    },
                    url: baseurl + "model/cvls/" + cvlId + "/values",
                    processData: false,
                    success: function (cvlValues) {
                        cvl.values = cvlValues;
                    },
                    error: function (xhr) {
                        console.log("Error occured.please try again");
                    }
                });
            }
        }

        function fetchspecifications(value) {
            hideSpecificationTemplate();

            if (value === "none") return;

            var foundEntities;
            $.ajax({
                type: "GET",
                dataType: "json",
                contentType: 'application/json',
                beforeSend: function (request) {
                    request.setRequestHeader("X-inRiver-APIKey", apikey);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader("Accept-Language", language);

                },
                url: baseurl + "workareafolder/" + value + "/entitylist",
                processData: false,
                success: function (entitylist) {
                    foundEntities = entitylist;

                    console.log("foundEntitiesShort:");
                    console.log(foundEntities);
                }, error: function (xhr) {
                    console.log("Error occured.please try again" + xhr);
                },
                complete: function () {
                    var specificationtemplaterowstyle = document.getElementById('specificationtemplaterow').style;
                    specificationtemplaterowstyle.display = 'table-row';

                    document.getElementById("specificationtemplateselection").innerHTML = '<div class="loader" />';

                    hideSelectFields();

                    specifications = new Object();
                    var chunkedFoundEntityIds = chunk(foundEntities.entityIds, chunkSize);
                    console.log('chunkedFoundEntityIds');
                    console.log(chunkedFoundEntityIds);
                    let process = forEachParallel(chunkedFoundEntityIds, getSpecificationNamesForEntityIds, 10);
                    process.done(results => {
                        fillspecificationnames(specifications);
                    });
                }
            });
        }

        const chunk = (arr, size) =>
            Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>
                arr.slice(i * size, i * size + size)
            );

        function getSpecificationNamesForEntityIds(entityIds) {
            return $.ajax({
                type: "POST",
                dataType: "json",
                contentType: 'application/json',
                data: JSON.stringify({
                    "entityIds": entityIds,
                    "objects": "SpecificationSummary",
                    "outbound": {
                        "linkTypeIds": specificationLinkTypeIds,
                        "objects": "FieldValues"
                    }
                }),
                beforeSend: function (request) {
                    request.setRequestHeader("X-inRiver-APIKey", apikey);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader("Accept-Language", language);

                },
                url: baseurl + "entities:fetchdata",
                processData: false,
                success: function (entities) {

                    foundEntities = entities;

                    console.log("Success fetching entities");
                    console.log(entities);

                    for (var i = 0; i < entities.length; i++) {
                        for (var j = 0; j < entities[i].outbound.length; j++) {
                            var specification = entities[i].outbound[j];
                            if (!(specification.entityId in specifications)) {
                                var specificationEntry = new Object();
                                specificationEntry.specificationName = specification.fieldValues.find(field => field.fieldTypeId === 'SpecificationName').value;
                                specificationEntry.entityCount = 1;
                                specifications[specification.entityId] = specificationEntry;
                            } else {
                                specifications[specification.entityId].entityCount++;
                            }
                        }
                    }

                    console.log("Specifications:");
                    console.log(specifications);
                }, error: function (xhr) {
                    console.log("Error occured.please try again: " + xhr);
                }
            })
                .done(result => ({}))
                .fail((_xhr, text) => ({}));
        }

        // https://codereview.stackexchange.com/questions/174310/process-array-with-x-parallel-executions
        function forEachParallel(arrayOfChunks, processChunksFunction, threads) {
            if (!$.isArray(arrayOfChunks)) throw new TypeError('First parameter must be an array');
            if (!$.isFunction(processChunksFunction)) throw new TypeError('Second parameter must be a function');
            if (!$.isNumeric(threads)) throw new TypeError('Third parameter must be a number');

            // The number of threads must be an integer
            threads = parseInt(threads);

            let masterDeferred = new $.Deferred();
            // To hold the result of each func(arr[i]) call
            let results = [];
            // To hold the deferreds that must be resolved before resolving masterDeferred
            let processes = [];
            let percentComplete = 0;

            // Map the input arr into an array of objects to preserve the index information.
            var queue = arrayOfChunks.map((value, index) => ({ index, value }));

            // Create a new "process" for each item in the queue, up to the thread limit
            for (let i = 0; i < Math.min(queue.length, threads); i++) {
                // Note: Don't blindly change `let` to `var` here or this will break
                // this depends on block scoping.
                let process = new $.Deferred();
                processes.push(process.promise());

                (function next() {
                    // Get the next item in the queue
                    let item = queue.shift();
                    if (!item) {
                        // If no items were found, this process is done.
                        process.resolve();
                        return;
                    }

                    // Call the function with the value at this index
                    processChunksFunction(item.value)
                        // Then update the results with the result
                        .done(result => results[item.index] = result)
                        .done(() => {
                            // Update percentage, calling any progress listeners
                            let newPercentage = Math.floor((arrayOfChunks.length - queue.length) * 100 / arrayOfChunks.length);
                            if (newPercentage > percentComplete) {
                                percentComplete = newPercentage;
                                masterDeferred.notify(percentComplete);
                            }
                            // Loop
                            next();
                        });
                }());
            }

            // Resolve the returned deferred value once processing is complete
            $.when(...processes).done(() => masterDeferred.resolve(results));

            return masterDeferred.promise();
        }

        function fillspecificationnames(specifications) {
            console.log('fillspecificationnames() called');

            var specificationnamesselectorhtml = '<select id="specificationnameselector" onchange="displayspecificationfields(this.value)">';
            specificationnamesselectorhtml += '<option value="none">-</option>';
            for (var key in specifications) {
                specificationnamesselectorhtml += '<option value="' + key + '">' + specifications[key].specificationName + " (" + specifications[key].entityCount + ")" + '</option>';
            }
            specificationnamesselectorhtml += "</select>";

            document.getElementById("specificationtemplateselection").innerHTML = specificationnamesselectorhtml;
        }

        function displayspecificationfields(specificationId) {
            hideSelectFields();

            if (specificationId == "none") return;

            selectedSpecificationId = specificationId;
            $.ajax({
                type: "GET",
                dataType: "json",
                contentType: 'application/json',
                beforeSend: function (request) {
                    request.setRequestHeader("X-inRiver-APIKey", apikey);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader("Accept-Language", language);

                }, // GET /api/v1.0.0/model/specificationtemplates/{templateId}/fieldtypes
                url: baseurl + "model/specificationtemplates/" + specificationId + "/fieldtypes",
                processData: false,
                success: function (specificationFields) {
                    console.log("Success fetching specification fields:");
                    console.log(specificationFields);

                    specificationFieldsArray = specificationFields;

                    specificationFieldsArray.forEach(function (item, index) {
                        if (item.dataType === "CVL") {
                            getCvlValues(item.cvlId);
                        }
                    });

                    fillInBuggedOutSpecificationFields(specificationFieldsArray);

                }, error: function (xhr) {
                    console.log("Error occured.please try again: " + xhr);
                },
                complete: function () {
                    var fieldtyperowstyle = document.getElementById('fieldtyperow').style;
                    fieldtyperowstyle.display = 'table-row';

                    specificationFieldsArray = specificationFieldsArray.sort(function (a, b) {
                        return a.index, b.index;
                    });

                    var categoryIds = [];
                    specificationFieldsArray.forEach(function (field, index) {
                        var foundCategoryId = categoryIds.find(function (categoryId) {
                            return field.categoryId === categoryId;
                        });
                        if (foundCategoryId === undefined || foundCategoryId === null) {
                            categoryIds.push(field.categoryId);
                        }
                    });

                    console.log('categoryIds');
                    console.log(categoryIds);

                    var fieldspecificationSelectHtml = '<ul><li><input type="checkbox" onclick="checkAllFieldSpecifications()" id="allFieldSpecificationChecker" />&nbsp;Check All</li></ul>';
                    fieldspecificationSelectHtml += '<ul id="fieldtypeselector">';
                    categoryIds.forEach(function (categoryId, index) {
                        fieldspecificationSelectHtml += '<li><b>' + categoryId + '</b></li>';
                        for (var i = 0; i < specificationFieldsArray.length; i++) {
                            var specificationField = specificationFieldsArray[i];
                            if (!specificationField.isDisabled || specificationField.format !== null) {
                                var disabled = " ";
                                if (categoryId === specificationField.categoryId) {
                                    if (specificationField.format !== null) {
                                        disabled = " disabled ";
                                    }

                                    var elementId = "";
                                    if (i == 0) {
                                        elementId = ' id="focusPoint"';
                                    }
                                    fieldspecificationSelectHtml += '<li><input type="checkbox"' + elementId + ' value="' + specificationFieldsArray[i].id + '"' + disabled + '/>&nbsp;' + specificationFieldsArray[i].name.en + '</li>';
                                }
                            }
                        }
                    });
                    fieldspecificationSelectHtml += "</ul>";
                    document.getElementById("fieldtypeselection").innerHTML = fieldspecificationSelectHtml;

                    showElement('tabs');
                }
            });
        }

        function checkAllFieldSpecifications() {
            var checkAllCheckbox = document.getElementById('allFieldSpecificationChecker');
            console.log('allFieldSpecificationChecker checked = ' + checkAllCheckbox.checked);
            if (checkAllCheckbox.checked == true) {
                $('#fieldtypeselection input[type="checkbox"').prop('checked', true);
            } else {
                $('#fieldtypeselection input[type="checkbox"').prop('checked', false);
            }
        }

        function fillInBuggedOutSpecificationFields(specificationFields) {
            specificationFields.forEach(function (specificationField, index) {
                var foundEntity = foundEntities.find(function (entity) {
                    var specification = findSpecficationById(entity.specification, specificationField.id);
                    return specification !== undefined;
                });

                if (foundEntity === undefined) {
                    specificationField.isDisabled = true;
                    return false;
                }

                var entitySpec = findSpecficationById(foundEntity.specification, specificationField.id);

                if (entitySpec === undefined) return false;

                specificationField.format = entitySpec.isFormatted ? "formatted" : null;
                specificationField.isDisabled = entitySpec.isReadOnly;
            });
        }

        function findSpecficationById(specifications, specificationId) {
            return specifications.find(function (spec) {
                return spec.specificationFieldTypeId === specificationId;
            });
        }

        function hideSpecificationTemplate() {
            hideElement('specificationtemplaterow');
            hideSelectFields();
        }

        function hideSelectFields() {
            hideElement('fieldtyperow');
            hideElement('tabs');
            hideElement('importFailureRow');
        }

        function hideElement(elementId) {
            var style = document.getElementById(elementId).style;
            style.display = 'none';
        }

        function showElement(elementId) {
            var element = document.getElementById(elementId).style;
            element.display = 'block';
        }

        function doExport() {
            var specificationFields = [];
            $("#fieldtypeselector input:checked").each(function () {
                var specFieldId = $(this).attr('value');
                var specificationField = specificationFieldsArray.find(function (specField) {
                    return specField.id == specFieldId;
                });
                specificationFields.push(specificationField);
            });

            console.log("specificationFields:");
            console.log(specificationFields);

            console.log("selectedSpecificationId:");
            console.log(selectedSpecificationId);

            var entitiesWithSelectedSpecification = [];
            foundEntities.forEach(function (entity) {
                if (entity.outbound.length > 0) {
                    if (entity.outbound[0].entityId == selectedSpecificationId) {
                        entitiesWithSelectedSpecification.push(entity);
                    }
                }
            });
            console.log("entitiesWithSelectedSpecification:");
            console.log(entitiesWithSelectedSpecification);

            var exportFormat = getExportFormat();

            var data = [];
            var header = _.map(predefinedColumns, function (column) { return column.columnName; });
            specificationFields.forEach(function (spec, index) {
                if (spec.dataType === "LocaleString") {
                    header.push(generateHeaderForLocaleString(spec.name[language]));
                } else {
                    header.push(spec.name[language]);
                }
            });
            data.push(header);

            if (exportFormat === "xlsx") {
                cvlSeparator = ',';
            }

            entitiesWithSelectedSpecification.forEach(function (entity, index) {
                var line = _.map(predefinedColumns, function (column) { return column.exportOperation(entity); });
                specificationFields.forEach(function (spec, index) {
                    var field = findSpecficationById(entity.specification, spec.id);
                    var fieldValue = field.displayValue;
                    if (field.specificationDataType === "LocaleString") {
                        fieldValue = splitLocaleStringToColumnValues(field.value);
                    } else if (field.specificationDataType === "DateTime") {
                        fieldValue = new Date(field.value).toISOString();
                    } else if (field.specificationDataType === "CVL" && field.isMultiValue) {
                        fieldValue = fieldValue.join(cvlSeparator);
                    }
                    else if (field.unit.length > 0 || field.specificationDataType === "CVL") {
                        fieldValue = field.value;
                    }
                    line.push(fieldValue);
                });
                data.push(line);
            });

            var specificationName = specifications[selectedSpecificationId].specificationName;
            download(specificationName, data, exportFormat);
        }

        function generateHeaderForLocaleString(specificationName) {
            var result = "";
            var divider = "";
            allLanguages.forEach(function (language, index) {
                result += divider + specificationName + "_" + language.name;
                divider = csvDivider;
            });
            return result;
        }

        function splitLocaleStringToColumnValues(localeString) {
            var result = "";
            var divider = "";
            allLanguages.forEach(function (language, index) {
                result += divider + localeString[language.name];
                divider = csvDivider;
            });
            return result;
        }

        function download(filename, data, exportFormat) {
            if (exportFormat === "csv") {
                var csv = "";
                data.forEach(function (line) {
                    var csvFields = line.join(csvDivider) + '\n';
                    csv += csvFields;
                });

                var element = document.createElement('a');
                element.setAttribute('href', 'data:text/csv;charset=utf-8,' + csv);
                element.setAttribute('download', filename + '.csv');
                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
            } else {
                var wb = XLSX.utils.book_new();
                var ws = XLSX.utils.aoa_to_sheet(data);
                XLSX.utils.book_append_sheet(wb, ws, filename);
                XLSX.writeFile(wb, filename + '.' + exportFormat);
            }
        }

        function getExportFormat() {
            var exportFormat = "xlsx";
            var exportFormatSelection = document.getElementsByName("exportFormatSelect");
            for (var i = 0; i < exportFormatSelection.length; ++i) {
                if (exportFormatSelection[i].checked || exportFormatSelection.length === 1) {
                    exportFormat = exportFormatSelection[i].value;
                    break;
                }
            }
            return exportFormat;
        }

        function doImport(files) {
            console.log(files);
            // Check for the various File API support.
            if (window.FileReader) {
                // FileReader are supported.
                getAsText(files[0]);
            } else {
                alert('FileReader are not supported in this browser.');
            }
        }

        function getAsText(fileToRead) {
            var reader = new FileReader();
            if (fileToRead.name.endsWith(".csv")) {
                reader.onload = loadHandlerCsv;
                reader.onerror = errorHandler;
                reader.readAsText(fileToRead);
            } else {
                reader.onload = loadHandlerXlsx;
                reader.onerror = errorHandler;
                reader.readAsBinaryString(fileToRead);
            }
        }

        function loadHandlerCsv(event) {
            var csv = event.target.result;
            if (csv.split(/\r\n|\n/)[0].split(',').length > 1) {
                csvDivider = ',';
            } else {
                csvDivider = ';';
            }
            toggleCvlSeparator();

            processImport(csv);

            setCsvDivider();
        }

        function loadHandlerXlsx(event) {
            var workbook = XLSX.read(event.target.result, { type: 'binary' });
            var csv = toCsv(workbook);

            csvDivider = ';';
            toggleCvlSeparator();
            processImport(csv);

            setCsvDivider();
        }

        function toCsv(workbook) {
            var result = [];
            workbook.SheetNames.forEach(function(sheetName) {
                var csv = XLSX.utils.sheet_to_csv(workbook.Sheets[sheetName], { FS: ";", strip: true });
                result.push(csv);
            });
            return result[0];
        }

        function TidyUpField(field) {
            if (field.startsWith('"')) {
                field = field.substr(1);
            }
            if (field.endsWith('"')) {
                field = field.substr(0, field.length - 1);
            }
            return field;
        }

        function processImport(csv) {
            var allTextLines = csv.split(/\r\n|\n/);
            var lines = [];
            for (var i = 0; i < allTextLines.length; i++) {
                var data = allTextLines[i].split(csvDivider);
                var tarr = [];
                for (var j = 0; j < data.length; j++) {
                    tarr.push(TidyUpField(data[j]));
                }
                lines.push(tarr);
            }
            console.log(lines);

            console.log("selectedSpecificationId: " + selectedSpecificationId);

            var entitiesWithSelectedSpecification = [];
            foundEntities.forEach(function (entity) {
                if (entity.outbound.length > 0) {
                    if (entity.outbound[0].entityId == selectedSpecificationId) {
                        entitiesWithSelectedSpecification.push(entity);
                    }
                }
            });
            console.log("EntitiesWithSelectedSpecification:");
            console.log(entitiesWithSelectedSpecification);

            var headerVerification = verifyHeader(lines[0]);
            var entitiesAndSpecificationsToUpdate = [];
            var validationFailureHtml = "";
            if (headerVerification.message.length == 0) {
                var skipHeader = true;
                lines.forEach(function (line, index) {
                    if (!skipHeader) {
                        var entityId = parseInt(line[0]);
                        var entity = entitiesWithSelectedSpecification.find(function (entity) {
                            return entity.entityId == entityId;
                        });

                        console.log("Row entity:");
                        console.log(entity);

                        var specificationName = specifications[selectedSpecificationId].specificationName;
                        if (entity !== undefined) {
                            var validationFailureListItems = "";
                            if (specificationName !== line[1]) {
                                validationFailureListItems += '<li>The SpecificationName column value <b>' + line[1] + '</b> does not match selected specification <b>' + specificationName + '</b></li>';
                            }

                            var entityAndSpecificationToUpdate = generateSpecificationValue(entityId, headerVerification.specificationFieldsMatchingHeader, line);
                            entitiesAndSpecificationsToUpdate.push(entityAndSpecificationToUpdate);
                            if (entityAndSpecificationToUpdate.validationFailures.length > 0) {
                                validationFailureListItems += _.map(entityAndSpecificationToUpdate.validationFailures,
                                    function (failure) {
                                        return '<li>' + failure + '</li>';
                                    }).join('');
                            }

                            if (validationFailureListItems.length > 0) {
                                validationFailureHtml += '<li>Entity ' + entityId;
                                validationFailureHtml += '<ul>';
                                validationFailureHtml += validationFailureListItems;
                                validationFailureHtml += '</ul>';
                                validationFailureHtml += '</li>';
                            }
                        }
                    } else {
                        skipHeader = false;
                    }
                });

                console.log('entitiesAndSpecificationsToUpdate');
                console.log(entitiesAndSpecificationsToUpdate);
                console.log(validationFailureHtml);

                if (validationFailureHtml.length > 0) {
                    showElement('importFailureRow');

                    document.getElementById("validationFailures").innerHTML = validationFailureHtml;
                } else {
                    var failedEntityIds = [];

                    var entityUpdateCount = 0;
                    var totalEntities = entitiesAndSpecificationsToUpdate.length;

                    document.getElementById("totalItems").innerHTML = "Total entities to update: " + totalEntities;

                    entitiesAndSpecificationsToUpdate.forEach(function (entityAndSpecifications, index) {
                        throttle.ajax({
                            type: "PUT",
                            dataType: "json",
                            contentType: 'application/json',
                            data: JSON.stringify(entityAndSpecifications.specificationValuesForUpdate),
                            beforeSend: function (request) {
                                request.setRequestHeader("X-inRiver-APIKey", apikey);
                                request.setRequestHeader("Accept", "application/json");
                                request.setRequestHeader("Accept-Language", language);

                            }, // PUT /api/v1.0.0/entities/{entityId}/specificationvalues
                            url: baseurl + "entities/" + entityAndSpecifications.entityId + "/specificationvalues",
                            processData: false,
                            success: function (specificationFields) {
                            },
                            error: function (xhr) {
                                failedEntityIds.push(entityAndSpecifications.entityId);

                                showElement('importFailureRow');
                                var failedHtml = "Failed entity id(s): ";
                                var divider = "";
                                failedEntityIds.forEach(function (id, index) {
                                    failedHtml += divider + id;
                                    divider = ',';
                                });

                                document.getElementById("failed").innerHTML = failedHtml;
                            },
                            complete: function () {
                                entityUpdateCount++;
                                document.getElementById("progress").innerHTML = "Progress: " + Math.round(entityUpdateCount / totalEntities * 100) + " %";
                            }
                        });
                    });
                }
            } else {
                alert('Imported file does not have a correct header. ' + headerVerification.message);
            }
        }

        function errorHandler(evt) {
            if (evt.target.error.name == "NotReadableError") {
                alert("Can not read file !");
            }
        }

        function generateSpecificationValue(entityId, specifications, line) {
            console.log("generateSpecificationValue:");
            console.log(specifications);

            var localeStringFields = new Object();
            var result = { entityId: entityId, specificationValuesForUpdate: [], validationFailures: [] };
            var valuePartLine = line.slice(2);

            console.log(valuePartLine);

            var specificationValue;
            for (var i = 0; i < valuePartLine.length; i++) {
                var skipValueToUpdate = false;
                specificationValue = new Object();
                specificationValue.specificationFieldTypeId = specifications[i].specificationField.id;
                if (specifications[i].specificationField.dataType === "CVL" && specifications[i].specificationField.isMultiValue) {
                    specificationValue.value = valuePartLine[i].split(cvlSeparator);
                } else if (specifications[i].specificationField.dataType === "LocaleString") {
                    if (localeStringFields[specifications[i].specificationField.id] === undefined) {
                        localeStringFields[specifications[i].specificationField.id] = new Object();
                    }
                    localeStringFields[specifications[i].specificationField.id][specifications[i].language] = valuePartLine[i];
                    skipValueToUpdate = true;
                } else {
                    if (specifications[i].specificationField.dataType === "Integer" ||
                        specifications[i].specificationField.dataType === "Double") {
                        specificationValue.value = Number(valuePartLine[i]);
                    } else if (specifications[i].specificationField.dataType === "Boolean") {
                        specificationValue.value = valuePartLine[i].toLowerCase() === "true";
                    } else {
                        specificationValue.value = valuePartLine[i];
                    }

                    var validationFunction = validations[specifications[i].specificationField.dataType];
                    if (validationFunction !== undefined) {
                        if (!validationFunction(specificationValue.value)) {
                            console.log("validation failed: " + specificationValue.value);
                            result.validationFailures.push("Column <b>" + specifications[i].specificationField.name[language] + "</b> of type <b>" + specifications[i].specificationField.dataType + "</b> with value <b>" + specificationValue.value + "</b> is not valid");
                        }
                    }
                }

                if (!skipValueToUpdate) {
                    result.specificationValuesForUpdate.push(specificationValue);
                }
            }

            console.log('generateSpecificationValue(): localeStringFields');
            console.log(localeStringFields);

            for (var key in localeStringFields) {
                specificationValue = new Object();
                specificationValue.specificationFieldTypeId = key;
                specificationValue.value = localeStringFields[key];
                result.specificationValuesForUpdate.push(specificationValue);
                console.log(specificationValue);
            };

            return result;
        }

        function verifyHeader(header) {
            var result = { message: "", specificationFieldsMatchingHeader: [] };

            if (header.length < predefinedColumns.length) {
                result.message = 'Header (and file) is not ' + csvDivider + '-separated';
                return result;
            }

            for (var i = 0; i < predefinedColumns.length; i++) {
                if (header[i] !== predefinedColumns[i].columnName) {
                    result.message = 'Column header number "' + (i + 1) + '" must have the name "' + predefinedColumns[i].columnName + '"';
                    return result;
                }
            }

            var specificationName = specifications[selectedSpecificationId].specificationName;
            for (var j = predefinedColumns.length; j < header.length; j++) {
                var specNameInHeaderParts = header[j].split('_');
                var specificationField = specificationFieldsArray.find(function (spec) {
                    return spec.name[language] === specNameInHeaderParts[0];
                });
                if (specificationField === undefined) {
                    result.message = 'Column "' + header[j] + '" is not part of the specification selected (= ' + specificationName + ')';
                } else {
                    var columnLanguage = "";
                    if (specNameInHeaderParts.length > 1) {
                        columnLanguage = specNameInHeaderParts[1];
                    }
                    result.specificationFieldsMatchingHeader.push({ specificationField: specificationField, language: columnLanguage });
                }

            }

            console.log('Header verification:');
            console.log(result);

            return result;
        }
    </script>

</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-lg-10">
                <h1>Specification Import Export</h1>
            </div>
            <div class="col-lg-2 pull-right">
                <br />
                <br />
                Separator:&nbsp;&nbsp;
                <select name="csvDividerSelect" onchange="setCsvDivider()">
                    <option value="comma" selected=""> ,</option>
                    <option value="semicolon"> ;</option>
                </select>
            </div>
        </div>
        <div class="row">
            <table class="table table-bordered">
                <thead class="thead-dark">
                    <tr>
                        <th scope="col">Step</th>
                        <th scope="col">Selection</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Workarea:</td>
                        <td id="workareaselection"></td>
                    </tr>
                    <tr id="specificationtemplaterow">
                        <td>Specification template:</td>
                        <td id="specificationtemplateselection"></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="tabs">
            <ul>
                <li><a href="#import">Import</a></li>
                <li><a href="#export">Export</a></li>
            </ul>
            <div id="import">
                <div class="row">
                    <div class="col-lg-4">
                        <div class="row">
                            <input type="file" id="doImport" accept=".csv,.xlsx" />
                        </div>
                    </div>
                    <div class="col-lg-8">
                        <div class="row">
                            <div class="col-lg-4">
                                <p id="totalItems"></p>
                            </div>
                            <div class="col-lg-4">
                                <p id="progress"></p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-8">
                                <p class="failed"></p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row" id="importFailureRow">
                    <br />
                    <br />
                    <p class="failed">Import failed. The following columns are not valid.</p>
                    <ul id="validationFailures"></ul>
                </div>
            </div>
            <div id="export">
                <div class="row">
                    <table class="table table-bordered">
                        <tbody>
                            <tr id="fieldtyperow">
                                <td>Select fields:</td>
                                <td id="fieldtypeselection"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="row">
                    <div class="col-lg-2">
                        <button onclick="doExport()" class="btn btn-primary" id="doExport">Export</button>
                    </div>
                    <div class="col-lg-2">
                        <select name="exportFormatSelect">
                            <option value="csv" selected=""> CSV</option>
                            <option value="xlsx"> XLSX</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <br />
            <br />
            <br />
        </div>
    </div>
</body>
</html>