<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Specification Import Export</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.15.1/moment.min.js"></script>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/js/bootstrap-multiselect.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/css/bootstrap-multiselect.css" type="text/css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datetimepicker/4.7.14/js/bootstrap-datetimepicker.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datetimepicker/4.7.14/css/bootstrap-datetimepicker.min.css">


    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.2.1/jstree.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.2.1/themes/default/style.min.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore.js"></script>

    <script type="text/javascript" src="https://unpkg.com/xlsx/dist/shim.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.26.0/polyfill.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/exceljs/dist/exceljs.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.8/FileSaver.min.js"></script>

    <style type="text/css">
        table {
            font-family: arial, sans-serif;
            border-collapse: collapse;
            width: 100%;
        }

        td, th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        #fieldtypeselection > ul {
            list-style-type: none;
            column-count: 3;
        }

            #fieldtypeselection > ul li {
                position: relative;
            }

                #fieldtypeselection > ul li > ul {
                    top: -12px;
                    left: 190px;
                    position: absolute;
                    visibility: hidden;
                    z-index: 1;
                    background: #ffffff;
                    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25);
                    list-style: none;
                    width: 190px;
                    padding: 10px 0;
                    font-size: 14px;
                    line-height: 16px;
                    letter-spacing: .02em;
                }

        input[type=text] {
            width: 100%;
        }

        input:invalid {
            border-color: red;
        }

        input, input:valid {
            border-color: #ccc;
        }

        .invalidTextarea {
            border-color: red;
            border-width: 2px;
        }

        .buttonInvalidForInput {
            cursor: not-allowed;
            pointer-events: none;
            /*Button disabled - CSS color class*/
            color: #c0c0c0;
            background-color: #ffffff;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #555;
            width: 24px;
            height: 24px;
            -webkit-animation: spin 2s linear infinite; /* Safari */
            animation: spin 2s linear infinite;
        }

        .optionGroup {
            font-weight: bold;
            font-style: italic;
        }

        .failed {
            color: red;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>

    <script>
        //BELOW IS CODE TO THROTTLE THE NUMBER OF AJAX REQUEST SO WE DO NOT GET STOPPED BY THE API.

        /**
         * ajaxthrottle.js
         *
         * Usage:
         *
         *     var t = $.ajaxthrottle({
         *        numRequestsPerTimePeriod : N,
         *        timePeriod               : P,
         *        maxConcurrent            : M
         *     });
         *
         *     t.ajax(args);
         *
         * This is just like calling $.ajax(args), except that requests are throttled
         * so that no more than N are initiated in any time period of P milliseconds,
         * and no more than M concurrent (outstanding at the same time) requests are allowed.
         * If N or P is 0, there is no time period based constraint, and if M is 0, there
         * is no constraint on the number of concurrent requests.
         *
         * Mark Phillips <mphillip@unca.edu>
         * Thu Dec 20 11:04:19 2012
         */
        (function ($) {
            $.ajaxthrottle = function (options) {

                var timeout,

                    settings = $.extend({
                        numRequestsPerTimePeriod: 0,
                        timePeriod: 0,
                        maxConcurrent: 9
                    }, options),

                    time = function () {
                        return (new Date()).getTime();
                    },

                    // Array of outstanding requests; these are requests that have
                    // been initiated with a call to $.ajax() but that have not
                    // completed yet.  Each entry in this array is an object of the form
                    //    {
                    //         arguments: the original arguments list passed to .ajax()
                    //              time: the time this request was passed to $.ajax()
                    //          deferred: the jQuery deferred object for this request
                    //    }
                    outstanding_reqs = [],

                    // Array of initiated requests; each entry in this array
                    // is an object just like the ones in the outstanding_reqs
                    // array above, but this array keeps track of all
                    // requests, regardless of whether they have completed.
                    // This list is used to keep track of how many requests
                    // have been initiated in settings.timePeriod.  Requests
                    // that are older than settings.timePeriod milliseconds
                    // get removed from this list when it is purged.
                    initiated_reqs = [],

                    // Array of requests waiting to be initiated
                    waiting_reqs = [],

                    // Purge the initiated reqs list so that it doesn't contain any
                    // reqs from more than settings.timePeriod ms ago.  Return the
                    // amount of time that needs to be waited until the oldest remaining
                    // (after purging) req in the list will be settings.timePeriod ms old.
                    // Do all of this relative to the passed in 'now' value.
                    purge_initiated_reqs = function (now) {
                        if (settings.timePeriod >= 0) {
                            while ((initiated_reqs.length > 0)
                                &&
                                (initiated_reqs[0].time + settings.timePeriod - now <= 0)) {
                                initiated_reqs.shift();
                            }
                            if (initiated_reqs.length > 0) {
                                return initiated_reqs[0].time + settings.timePeriod - now;
                            }
                        }
                        return 0;
                    },

                    // remove a req from the outstanding_reqs list
                    remove_outstanding_req = function (obj) {
                        $.each(outstanding_reqs, function (i) {
                            if (outstanding_reqs[i] === obj) {
                                outstanding_reqs.splice(i, 1);
                                return false;
                            }
                            return true;
                        });
                    },

                    // Initiate the next request on the waiting list, unless we need to wait
                    // till some time has passed or some outstanding requests have completed.
                    process_waiting = function () {
                        var now = time(),
                            delay, req, deferred;

                        if (waiting_reqs.length <= 0) {
                            return;
                        }

                        delay = purge_initiated_reqs(now);

                        // If we have a timePeriod constraint, and the max number of allowed
                        // requests have gone out in that time period, arrange to wait for
                        // 'delay' ms
                        if ((settings.numRequestsPerTimePeriod > 0) && (settings.timePeriod > 0)
                            &&
                            (delay > 0)
                            &&
                            (initiated_reqs.length >= settings.numRequestsPerTimePeriod)) {
                            // clear any existing timeout first, because this one will
                            // require waiting till after it would finish anyway
                            if (timeout !== undefined) {
                                clearTimeout(timeout);
                            }
                            timeout = setTimeout(function () {
                                timeout = undefined;
                                process_waiting();
                            }, delay);
                            return;
                        }

                        // If the max number of allowed requests is outstanding, do nothing;
                        // process_waiting() will get called again when a request completes.
                        if ((settings.maxConcurrent > 0)
                            &&
                            (outstanding_reqs.length >= settings.maxConcurrent)) {
                            return;
                        }

                        // If we make it to here, then it's OK to initiate the next
                        // request in the waiting list
                        req = waiting_reqs.shift();
                        req.time = time();
                        initiated_reqs.push(req);
                        outstanding_reqs.push(req);
                        $.ajax.apply($, req.arguments).done(function () {
                            req.deferred.resolve.apply(req.deferred, arguments);
                        }).fail(function () {
                            req.deferred.reject.apply(req.deferred, arguments);
                        }).always(function () {
                            remove_outstanding_req(req);
                            process_waiting();
                        });

                    }
                    ;

                return {
                    ajax: function () {
                        var deferred = $.Deferred();
                        waiting_reqs.push({ arguments: arguments, deferred: deferred });
                        process_waiting();
                        return deferred.promise();
                    }
                };
            };
        }(jQuery));

        //SETUP THROTTLE SO WE MAX DO 9 CONCURRENT REQUEST ELSE WE WILL GET BLOCKED BY THE REST API.
        var throttle = $.ajaxthrottle({
            numRequestsPerTimePeriod: 0,
            timePeriod: 0,
            maxConcurrent: 9
        });
        //t.ajax(args);
    </script>

    <script type="text/javascript">
        //THIS NEED TO BE UPDATED FOR THE SPECIFIC ENVIRONMENT
        var fallbackApiKey = "145a024134fc97d14777edf0323c244f";
        var apiKey = fallbackApiKey;
        var apiKeyUserCVL = "ApiKeyUser";
        var language = "en";
        var baseUrl = "https://apieuw.productmarketingcloud.com/api/v1.0.0/";

        var specificationTypeId = "Specification";
        var specificationTemplateChunkSize = 100;

        var foundEntities;
        var workAreasArray;
        var specificationFieldsArray;
        var allCvls = [];
        var specificationLinkTypes;
        var selectedSpecificationId;
        var specificationLinkTypeIds = "ProductSpecifications,Item2SpecificationCorrect";
        var allLanguages;
        var showDataType = false;
        var specifications = new Object();
        var csvDivider;
        var cvlSeparator;
        var specificationMainNameField = 'SpecificationName';
        var specificationNameColumnIndex;

        var predefinedColumns = [
            {
                columnName: function (entity) {
                    return "EntityId";
                },
                exportOperation: function (entity) {
                    return entity.entityId;
                }
            },
            {
                columnName: function (entity) {
                    if (entity !== null && entity !== undefined) {
                        if (entity.summary.entityTypeId === "Product") {
                            return "ProductNumber";
                        }
                        else if (entity.summary.entityTypeId === "Item") {
                            return "ItemNumber";
                        }
                    }
                    return "-";
                },
                exportOperation: function (entity) {
                    var field = entity.fields.find(function (field) {
                        return field.fieldTypeId === "ItemNumber" || field.fieldTypeId === "ProductNumber";
                    });
                    if (field !== undefined) {
                        return field.displayValue;
                    }
                    return "-";
                }
            },
            {
                columnName: function (entity) {
                    return specificationMainNameField;
                },
                exportOperation: function (entity) {
                    return specifications[selectedSpecificationId].specificationName;
                }
            }
        ];
        var validations = {
            "Integer": function (value) {
                var exp = /^([+-]?[0-9]*)$/.test(value);
                console.log("Integer: " + value + ", exp: " + exp);
                return exp;
            },
            "Double": function (value) {
                var exp = /^([1-9]\d*(\.|\,)\d*|0?(\.|\,)\d*[1-9]\d*|[1-9]\d*)$/gm.test(value);
                console.log("Double: " + value + ", exp: " + exp);
                return exp;
            },
            "DateTime": function (value) {
                var exp = /^(\d{4})(-(\d{2}))??(-(\d{2}))??(T(\d{2}):(\d{2})(:(\d{2}))??(\.(\d+))??(([\+\-]{1}\d{2}:\d{2})|Z)??)??$/.test(value);
                console.log("DateTime: " + value + ", exp: " + exp);
                return exp;
            }
        };

        var validationAdditionalEntityInformation = function (entity) {
            var itemNumberField = entity.fields.find(function (field) {
                return field.fieldTypeId === "ItemNumber";
            });
            if (itemNumberField !== undefined) {
                return ": Item Number = " + itemNumberField.displayValue;
            }
            var productNumberField = entity.fields.find(function (field) {
                return field.fieldTypeId === "ProductNumber";
            });
            if (productNumberField !== undefined) {
                return ": Product Number = " + productNumberField.displayValue;
            }
            return "";
        };

        var excelTabs = [
            '_', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
            'U', 'V', 'W', 'X', 'Y', 'Z', 'AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'AG', 'AH', 'AI', 'AJ', 'AK', 'AL', 'AM',
            'AN', 'AO', 'AP', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AV', 'AW', 'AX', 'AY', 'AZ', 'BA', 'BB', 'BC', 'BD', 'BE',
            'BF', 'BG', 'BH', 'BI', 'BJ', 'BK', 'BL', 'BM', 'BN', 'BO', 'BP', 'BQ', 'BR', 'BS', 'BT', 'BU', 'BV', 'BW',
            'BX', 'BY', 'BZ', 'CA', 'CB', 'CC', 'CD', 'CE', 'CF', 'CG', 'CH', 'CI', 'CJ', 'CK', 'CL', 'CM', 'CN', 'CO',
            'CP', 'CQ', 'CR', 'CS', 'CT', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ'
        ];

        window.onload = function () {
            fetchAllOutboundSpecificationLinkTypeIds();

            fetchAllCvls();
            setApiKeyToMatchUser();

            fetchWorkAreas();
            fetchAllLanguages();
            hideSpecificationTemplate();

            $("#tabs").tabs();

            var xlf = document.getElementById('doImport');
            if (!xlf.addEventListener) return;
            function handleFile(e) { doImport(e.target.files); }
            xlf.addEventListener('change', handleFile, false);

            specificationNameColumnIndex = undefined;
            predefinedColumns.forEach(function (column, index) {
                if (column.columnName(null) === specificationMainNameField) {
                    specificationNameColumnIndex = index;
                }
            });
            console.log('specificationNameColumnIndex: ' + specificationNameColumnIndex);
        }

        function hasTemplateContext() {
            return typeof templateContext !== "undefined";
        }

        function setApiKeyToMatchUser() {
            if (hasTemplateContext()) {
                getCvlValues(apiKeyUserCVL, false);

                var cvlForApiKeyUser = allCvls.find(function (cvl) {
                    return cvl.id === apiKeyUserCVL;
                });
                if (cvlForApiKeyUser !== undefined && cvlForApiKeyUser !== null) {
                    console.log(cvlForApiKeyUser.values);
                    var apiKeyUser = cvlForApiKeyUser.values.find(function (keyValue) {
                        return keyValue.value === templateContext.userEmail;
                    });
                    if (apiKeyUser !== undefined && apiKeyUser !== null) {
                        apiKey = apiKeyUser.key;
                        console.log("Found user with userEmail = " + templateContext.userEmail);
                    };
                }
            }
        }

        function buildAjaxSettings(restOperation, asyncOperation = true) {
            var ajaxSettings = {
                dataType: "json",
                contentType: 'application/json',
                headers: {
                    'X-inRiver-APIKey': apiKey,
                    'Accept': 'application/json',
                    'Accept-Language': language
                },
                url: baseUrl + restOperation,
                processData: true,
                async: asyncOperation
            };
            return ajaxSettings;
        }

        function setCsvDivider() {
            var divider = "";
            var csvDividerSelection = document.getElementsByName("csvDividerSelect");
            for (var i = 0; i < csvDividerSelection.length; ++i) {
                if (csvDividerSelection[i].checked || csvDividerSelection.length === 1) {
                    divider = csvDividerSelection[i].value;
                    break;
                }
            }

            if (divider === "comma") {
                csvDivider = ',';
            } else {
                csvDivider = ';';
            }

            toggleCvlSeparator();

            console.log('setCsvDivider: csvDivider = ' + csvDivider + ', cvlSeparator = ' + cvlSeparator);
        }

        function toggleCvlSeparator() {
            if (csvDivider === ',') {
                cvlSeparator = ';';
            } else {
                cvlSeparator = ',';
            }

        }

        function fetchWorkAreas() {
            $.getJSON(buildAjaxSettings("workareafoldertree?includeCreatedByMe=true"), function (workAreaFolderTree) {
                console.log("Success");
                console.log(workAreaFolderTree);
                workAreasArray = workAreaFolderTree;
                console.log(workAreasArray.length);

                var workareasselectorhtml = '<div id="workareaselector">';
                workareasselectorhtml += '<ul>';
                workareasselectorhtml += renderTree("p_", hasTemplateContext() ? templateContext.userDisplayName : "Private", "topLevelPrivate");
                workareasselectorhtml += renderTree("s_", "Common Shared", "topLevelCommonShared");
                workareasselectorhtml += "</ul>";
                workareasselectorhtml += "</div>";

                document.getElementById("workareaselection").innerHTML = workareasselectorhtml;

                $('#workareaselector').jstree({
                    'plugins': ["wholerow", "types"]
                });
                $('#workareaselector').jstree("open_node", $('#topLevelPrivate'));
                $('#workareaselector').jstree("open_node", $('#topLevelCommonShared'));

                $('#workareaselector').on("changed.jstree", function (e, data) {
                    console.log(data.node.li_attr.value);
                    fetchSpecifications(data.node.li_attr.value);
                });
            });
        }

        function renderTree(prefix, rootNodeName, topLevelId) {
            var html = '<li id="' + topLevelId + '" value="none">' + rootNodeName;
            html += '<ul>';
            for (var i = 0; i < workAreasArray.length; i++) {
                if (workAreasArray[i].id.startsWith(prefix)) {
                    if (workAreasArray[i].folders !== undefined) {
                        html += renderWorkareaSubLevels(workAreasArray[i]);
                    }
                    else {
                        html += '<li value="' + workAreasArray[i].id + '" >' + workAreasArray[i].name + '</li>';
                    }
                }
            }
            html += "</li>";
            html += "</ul>";

            return html;
        }

        function renderWorkareaSubLevels(workarea) {
            var workareasselectorhtml = '<li value="' + workarea.id + '">' + workarea.name;
            workareasselectorhtml += '<ul>';
            for (var j = 0; j < workarea.folders.length; j++) {
                if (workarea.folders[j].folders !== undefined) {
                    workareasselectorhtml += renderWorkareaSubLevels(workarea.folders[j]);
                } else {
                    workareasselectorhtml += '<li value="' + workarea.folders[j].id + '" >' + workarea.folders[j].name + '</li>';
                }
            }
            workareasselectorhtml += "</ul>";
            workareasselectorhtml += "</li>";

            return workareasselectorhtml;
        }

        function fetchAllCvls() {
            $.getJSON(buildAjaxSettings("model/cvls", false), function (cvls) {
                cvls.forEach(function (item, index) {
                    var cvlWithValues = item;
                    cvlWithValues.values = [];
                    allCvls.push(cvlWithValues);
                });
                console.log('allCvls');
                console.log(allCvls);
            });
        }

        function fetchAllLanguages() {
            $.getJSON(buildAjaxSettings("model/languages"), function (languages) {
                allLanguages = languages;
                console.log(allLanguages);
            });
        }

        function fetchAllOutboundSpecificationLinkTypeIds() {
            specificationLinkTypeIds = "";
            $.getJSON(buildAjaxSettings("model/entitytypes"), function (entityTypes) {
                var specification = entityTypes.find(function (entityType) {
                    return entityType.id === specificationTypeId;
                });
                specificationLinkTypeIds = specification.inboundLinkTypes.join(",");
                console.log(specificationLinkTypeIds);

                specificationMainNameField = specification.displayNameFieldTypeId;
            });
        }

        function getCvlValues(cvlId, asyncOperation) {
            var cvl = allCvls.find(function (cvl) {
                return cvl.id === cvlId;
            });
            console.log("Found cvl for cvlId = " + cvlId);
            console.log(cvl);
            if (cvl.values.length === 0) {
                $.getJSON(buildAjaxSettings("model/cvls/" + cvlId + "/values", asyncOperation), function (cvlValues) {
                    cvl.values = cvlValues;
                });
            }
        }

        function fetchSpecifications(value) {
            hideSpecificationTemplate();

            if (value === "none") return;

            var entities;
            $.getJSON(buildAjaxSettings("workareafolder/" + value + "/entitylist"), function (entitylist) {
                entities = entitylist;

                console.log("entities:");
                console.log(entities);

                var specificationtemplaterowstyle = document.getElementById('specificationtemplaterow').style;
                specificationtemplaterowstyle.display = 'table-row';

                document.getElementById("specificationtemplateselection").innerHTML = '<div class="loader" />';

                hideSelectFields();

                foundEntities = [];
                specifications = new Object();
                var chunkedFoundEntityIds = chunk(entities.entityIds, specificationTemplateChunkSize);

                foundEntities = [];
                console.log('chunkedFoundEntityIds');
                console.log(chunkedFoundEntityIds);

                var specificationnamesselectorhtml = '<select id="specificationnameselector" onchange="displayspecificationfields(this.value)">';
                specificationnamesselectorhtml += '<option value="none">-</option>';
                specificationnamesselectorhtml += "</select>";
                document.getElementById("specificationtemplateselection").innerHTML = specificationnamesselectorhtml;


                forEachParallel(chunkedFoundEntityIds, getSpecificationNamesForEntityIds, 10);
            });
        }

        const chunk = (arr, size) =>
            Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>
                arr.slice(i * size, i * size + size)
            );

        function getSpecificationNamesForEntityIds(entityIds) {
            var ajaxSettings = buildAjaxSettings("entities:fetchdata");
            ajaxSettings.data = JSON.stringify({
                "entityIds": entityIds,
                "objects": "EntitySummary,FieldsSummary,SpecificationSummary",
                "outbound": {
                    "linkTypeIds": specificationLinkTypeIds,
                    "objects": "FieldValues"
                }
            });

            return $.post(ajaxSettings, function (entities) {
                foundEntities = foundEntities.concat(entities);

                console.log("Success fetching entities");
                console.log(entities);

                for (var i = 0; i < entities.length; i++) {
                    for (var j = 0; j < entities[i].outbound.length; j++) {
                        var specification = entities[i].outbound[j];
                        if (!(specification.entityId in specifications)) {
                            var specificationEntry = new Object();
                            specificationEntry.specificationName = specification.fieldValues
                                .find(field => field.fieldTypeId === specificationMainNameField).value;
                            specificationEntry.entityCount = 1;
                            specifications[specification.entityId] = specificationEntry;
                        } else {
                            specifications[specification.entityId].entityCount++;
                        }
                    }
                }

                fillSpecificationNames(specifications);
            });
        }

        // https://codereview.stackexchange.com/questions/174310/process-array-with-x-parallel-executions
        function forEachParallel(arrayOfChunks, processChunksFunction, threads) {
            if (!$.isArray(arrayOfChunks)) throw new TypeError('First parameter must be an array');
            if (!$.isFunction(processChunksFunction)) throw new TypeError('Second parameter must be a function');
            if (!$.isNumeric(threads)) throw new TypeError('Third parameter must be a number');

            // The number of threads must be an integer
            threads = parseInt(threads);

            let masterDeferred = new $.Deferred();
            // To hold the result of each func(arr[i]) call
            let results = [];
            // To hold the deferreds that must be resolved before resolving masterDeferred
            let processes = [];
            let percentComplete = 0;

            // Map the input arr into an array of objects to preserve the index information.
            var queue = arrayOfChunks.map((value, index) => ({ index, value }));

            // Create a new "process" for each item in the queue, up to the thread limit
            for (let i = 0; i < Math.min(queue.length, threads); i++) {
                // Note: Don't blindly change `let` to `var` here or this will break
                // this depends on block scoping.
                let process = new $.Deferred();
                processes.push(process.promise());

                (function next() {
                    // Get the next item in the queue
                    let item = queue.shift();
                    if (!item) {
                        // If no items were found, this process is done.
                        process.resolve();
                        return;
                    }

                    // Call the function with the value at this index
                    processChunksFunction(item.value)
                        // Then update the results with the result
                        .done(result => results[item.index] = result)
                        .done(() => {
                            // Update percentage, calling any progress listeners
                            let newPercentage = Math.floor((arrayOfChunks.length - queue.length) * 100 / arrayOfChunks.length);
                            if (newPercentage > percentComplete) {
                                percentComplete = newPercentage;
                                masterDeferred.notify(percentComplete);
                            }
                            // Loop
                            next();
                        });
                }());
            }

            // Resolve the returned deferred value once processing is complete
            $.when(...processes).done(() => masterDeferred.resolve(results));

            return masterDeferred.promise();
        }

        function fillSpecificationNames(specifications) {
            var specificationsClone = JSON.parse(JSON.stringify(specifications));
            $("#specificationnameselector > option").each(function () {
                var key = $(this).attr("value");
                if (key !== "none") {
                    var specification = specifications[key];
                    $(this).text(specifications[key].specificationName + " (" + specifications[key].entityCount + ")");
                    delete specificationsClone[key];
                }
            });

            for (var key in specificationsClone) {
                $("#specificationnameselector").append('<option value="' + key + '">' + specifications[key].specificationName + " (" + specifications[key].entityCount + ")" + '</option>');
            }
        }

        function displayspecificationfields(specificationId) {
            hideSelectFields();

            if (specificationId == "none") return;

            selectedSpecificationId = specificationId;
            $.getJSON(buildAjaxSettings("model/specificationtemplates/" + specificationId + "/fieldtypes"), function (specificationFields) {
                console.log("Success fetching specification fields:");
                console.log(specificationFields);

                specificationFieldsArray = specificationFields;

                specificationFieldsArray.forEach(function (item, index) {
                    if (item.dataType === "CVL") {
                        getCvlValues(item.cvlId, true);
                    }
                });

                ensureSpecificationFields(specificationFieldsArray);

                var fieldtyperowstyle = document.getElementById('fieldtyperow').style;
                fieldtyperowstyle.display = 'table-row';

                specificationFieldsArray = specificationFieldsArray.sort(function (a, b) {
                    return a.index, b.index;
                });

                var categoryIds = [];
                specificationFieldsArray.forEach(function (field, index) {
                    var foundCategoryId = categoryIds.find(function (categoryId) {
                        return field.categoryId === categoryId;
                    });
                    if (foundCategoryId === undefined || foundCategoryId === null) {
                        categoryIds.push(field.categoryId);
                    }
                });

                console.log('categoryIds');
                console.log(categoryIds);

                var fieldspecificationSelectHtml = '<ul><li><input type="checkbox" onclick="checkAllFieldSpecifications()" id="allFieldSpecificationChecker" />&nbsp;Check All</li></ul>';
                fieldspecificationSelectHtml += '<ul id="fieldtypeselector">';
                categoryIds.forEach(function (categoryId, index) {
                    fieldspecificationSelectHtml += '<li><b>' + categoryId + '</b></li>';
                    for (var i = 0; i < specificationFieldsArray.length; i++) {
                        var specificationField = specificationFieldsArray[i];
                        if (!specificationField.isDisabled || specificationField.format !== null) {
                            var disabled = " ";
                            if (categoryId === specificationField.categoryId) {
                                if (specificationField.format !== null) {
                                    disabled = " disabled ";
                                }

                                var elementId = "";
                                if (i == 0) {
                                    elementId = ' id="focusPoint"';
                                }
                                fieldspecificationSelectHtml += '<li><input type="checkbox"' + elementId + ' value="' + specificationFieldsArray[i].id + '"' + disabled + '/>&nbsp;' + specificationFieldsArray[i].name[language] + '</li>';
                            }
                        }
                    }
                });
                fieldspecificationSelectHtml += "</ul>";
                document.getElementById("fieldtypeselection").innerHTML = fieldspecificationSelectHtml;

                showElement('tabs');
            });
        }

        function checkAllFieldSpecifications() {
            var checkAllCheckbox = document.getElementById('allFieldSpecificationChecker');
            console.log('allFieldSpecificationChecker checked = ' + checkAllCheckbox.checked);
            if (checkAllCheckbox.checked == true) {
                $('#fieldtypeselection input[type="checkbox"').prop('checked', true);
            } else {
                $('#fieldtypeselection input[type="checkbox"').prop('checked', false);
            }
        }

        function ensureSpecificationFields(specificationFields) {
            specificationFields.forEach(function (specificationField, index) {
                var foundEntity = foundEntities.find(function (entity) {
                    var specification = findSpecificationById(entity.specification, specificationField.id);
                    return specification !== undefined;
                });

                if (foundEntity === undefined) {
                    specificationField.isDisabled = true;
                    return false;
                }

                var entitySpec = findSpecificationById(foundEntity.specification, specificationField.id);

                if (entitySpec === undefined) return false;

                specificationField.format = entitySpec.isFormatted ? "formatted" : null;
                specificationField.isDisabled = entitySpec.isReadOnly;
            });
        }

        function findSpecificationById(specifications, specificationId) {
            return specifications.find(function (spec) {
                return spec.specificationFieldTypeId === specificationId;
            });
        }

        function hideSpecificationTemplate() {
            hideElement('specificationtemplaterow');
            hideSelectFields();
        }

        function hideSelectFields() {
            hideElement('fieldtyperow');
            hideElement('tabs');
            hideElement('importFailureRow');
        }

        function hideElement(elementId) {
            var style = document.getElementById(elementId).style;
            style.display = 'none';
        }

        function showElement(elementId) {
            var element = document.getElementById(elementId).style;
            element.display = 'block';
        }

        function doExport() {
            var specificationFields = [];
            $("#fieldtypeselector input:checked").each(function () {
                var specFieldId = $(this).attr('value');
                var specificationField = specificationFieldsArray.find(function (specField) {
                    return specField.id == specFieldId;
                });
                specificationFields.push(specificationField);
            });

            console.log("specificationFields:");
            console.log(specificationFields);

            console.log("selectedSpecificationId:");
            console.log(selectedSpecificationId);

            var entitiesWithSelectedSpecification = [];
            foundEntities.forEach(function (entity) {
                if (entity.outbound.length > 0) {
                    if (entity.outbound[0].entityId == selectedSpecificationId) {
                        entitiesWithSelectedSpecification.push(entity);
                    }
                }
            });
            console.log("entitiesWithSelectedSpecification:");
            console.log(entitiesWithSelectedSpecification);

            var exportFormat = getSelectedExportFormat();

            var data = [];
            var header = generateHeader(specificationFields, entitiesWithSelectedSpecification);
            console.log(header);
            data.push(header);

            setCsvDivider();
            if (exportFormat === "xlsx") {
                cvlSeparator = ',';
            }

            var usedCvls = _.map(predefinedColumns, function (column) { return ""; });
            specificationFields.forEach(function (spec, index) {
                if (spec.cvlId) {
                    usedCvls.push(spec.cvlId);
                } else {
                    usedCvls.push("");
                }
            });

            entitiesWithSelectedSpecification.forEach(function (entity, index) {
                var line = _.map(predefinedColumns, function (column) { return column.exportOperation(entity); });
                specificationFields.forEach(function (spec, index) {
                    var field = findSpecificationById(entity.specification, spec.id);

                    var fieldValue;
                    if (field.specificationDataType === "CVL") {
                        fieldValue = field.value;
                    } else {
                        fieldValue = field.displayValue;
                    }

                    var push = true;
                    if (field.specificationDataType === "LocaleString") {
                        splitLocaleStringToColumnValues(field.value).forEach(function (ls) {
                            line.push(ls);
                        });
                        push = false;
                    } else if (field.specificationDataType === "DateTime") {
                        fieldValue = new Date(field.value).toISOString();
                    } else if (field.specificationDataType === "CVL" && field.isMultiValue) {
                        fieldValue = fieldValue != null ? fieldValue.join(cvlSeparator) : [];
                    }
                    else if (field.unit.length > 0 || field.specificationDataType === "CVL") {
                        fieldValue = field.value;
                    }
                    if (push) {
                        line.push(fieldValue);
                    }
                });
                data.push(line);
            });

            var specificationName = specifications[selectedSpecificationId].specificationName;
            download(specificationName, data, usedCvls, exportFormat);
        }

        function generateHeader(specificationFields, entitiesWithSelectedSpecification) {
            var entity = entitiesWithSelectedSpecification[0];

            console.log("generateHeader");
            console.log(entity);

            var header = _.map(predefinedColumns, function (column) { return column.columnName(entity); });
            specificationFields.forEach(function (spec, index) {
                if (spec.dataType === "LocaleString") {
                    generateHeaderForLocaleString(spec.name[language]).forEach(function (ls) {
                        header.push(ls);
                    });
                } else {
                    header.push(spec.name[language]);
                }
            });

            return header;
        }

        function generateHeaderForLocaleString(specificationName) {
            var result = [];
            allLanguages.forEach(function (language, index) {
                result.push(specificationName + "_" + language.name);
            });
            return result;
        }

        function splitLocaleStringToColumnValues(localeString) {
            var result = [];
            allLanguages.forEach(function (language, index) {
                result.push(localeString[language.name]);
            });
            return result;
        }

        function download(filename, data, usedCvls, exportFormat) {
            if (exportFormat === "csv") {
                var csv = "";
                data.forEach(function (line) {
                    var csvFields = line.join(csvDivider) + '\n';
                    csv += csvFields;
                });

                var element = document.createElement('a');
                element.setAttribute('href', 'data:text/csv;charset=utf-8,' + csv);
                element.setAttribute('download', filename + '.csv');
                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
            } else {

                console.log("Download Excel");
                console.log(usedCvls);
                console.log(data);

                var workbook = new ExcelJS.Workbook();
                var dataSheet = workbook.addWorksheet(filename);
                var cvlValidationProperties = GenerateCVLWorksheet(usedCvls, workbook);

                console.log('cvlValidationProperties');
                console.log(cvlValidationProperties);

                data.forEach(function (line) {
                    dataSheet.addRow(line);
                });

                for (var i = 0; i < data[0].length; i++) {
                    var cvlId = usedCvls[i];
                    if (cvlId.length > 0) {
                        for (var j = 0; j < data.length - 1; j++) {
                            var cellId = excelTabs[i + 1] + (j + 2);
                            var validationExpression = cvlValidationProperties.find(function (prop) {
                                return prop.cvlId === cvlId;
                            });
                            dataSheet.getCell(cellId).dataValidation = {
                                type: 'list',
                                allowBlank: true,
                                formulae: [validationExpression.validationExpression]
                            };
                        }
                    }
                }

                workbook.xlsx.writeBuffer()
                    .then(buffer => saveAs(new Blob([buffer]), filename + '.' + exportFormat))
                    .catch(err => console.log('Error writing excel export', err));

                //var wb = XLSX.utils.book_new();
                //var ws = XLSX.utils.aoa_to_sheet(data);
                //XLSX.utils.book_append_sheet(wb, ws, filename);
                //XLSX.writeFile(wb, filename + '.' + exportFormat);
            }
        }

        function GenerateCVLWorksheet(usedCvls, workbook) {
            var sheetName = "CVLs";
            var cvlSheet = workbook.addWorksheet(sheetName);
            cvlSheet.state = 'hidden';

            var validationData = [];
            var currentSheetColumn = 1;
            usedCvls.forEach(function (cvlId) {
                var matchingCvl = allCvls.find(function (cvl) {
                    return cvl.id === cvlId;
                });

                if (matchingCvl !== undefined) {
                    var column = [];
                    column.push(cvlId);
                    matchingCvl.values.forEach(function (value) {
                        column.push(value.key);
                    });
                    cvlSheet.getColumn(currentSheetColumn).values = column;
                    var tabId = excelTabs[currentSheetColumn];
                    validationData.push({ cvlId: cvlId, validationExpression: sheetName + "!$" + tabId + "$2:$" + tabId + "$" + column.length });
                    currentSheetColumn++;
                }
            });
            return validationData;
        }

        function getSelectedExportFormat() {
            var exportFormat = "xlsx";
            var exportFormatSelection = document.getElementsByName("exportFormatSelect");
            for (var i = 0; i < exportFormatSelection.length; ++i) {
                if (exportFormatSelection[i].checked || exportFormatSelection.length === 1) {
                    exportFormat = exportFormatSelection[i].value;
                    break;
                }
            }
            return exportFormat;
        }

        function doImport(files) {
            hideElement('importFailureRow');

            console.log(files);
            // Check for the various File API support.
            if (window.FileReader) {
                // FileReader are supported.
                getAsText(files[0]);
            } else {
                alert('FileReader are not supported in this browser.');
            }
        }

        function getAsText(fileToRead) {
            var reader = new FileReader();
            if (fileToRead.name.endsWith(".csv")) {
                reader.onload = loadHandlerCsv;
                reader.onerror = errorHandler;
                reader.readAsText(fileToRead);
            } else {
                reader.onload = loadHandlerXlsx;
                reader.onerror = errorHandler;
                reader.readAsBinaryString(fileToRead);
            }
        }

        function loadHandlerCsv(event) {
            var csv = event.target.result;
            if (csv.split(/\r\n|\n/)[0].split(',').length > 1) {
                csvDivider = ',';
            } else {
                csvDivider = ';';
            }
            toggleCvlSeparator();

            processImport(csv);

            setCsvDivider();
        }

        function loadHandlerXlsx(event) {
            var workbook = XLSX.read(event.target.result, { type: 'binary' });
            var csv = toCsv(workbook);

            csvDivider = ';';
            toggleCvlSeparator();
            processImport(csv);

            setCsvDivider();
        }

        function toCsv(workbook) {
            var result = [];
            workbook.SheetNames.forEach(function (sheetName) {
                var csv = XLSX.utils.sheet_to_csv(workbook.Sheets[sheetName], { FS: ";", strip: true });
                result.push(csv);
            });
            return result[0];
        }

        function TidyUpField(field) {
            if (field.startsWith('"')) {
                field = field.substr(1);
            }
            if (field.endsWith('"')) {
                field = field.substr(0, field.length - 1);
            }
            return field;
        }

        function processImport(csv) {
            var allTextLines = csv.split(/\r\n|\n/);
            var lines = [];
            for (var i = 0; i < allTextLines.length; i++) {
                var data = allTextLines[i].split(csvDivider);
                var tarr = [];
                for (var j = 0; j < data.length; j++) {
                    tarr.push(TidyUpField(data[j]));
                }
                lines.push(tarr);
            }
            console.log(lines);

            console.log("selectedSpecificationId: " + selectedSpecificationId);

            var entitiesWithSelectedSpecification = [];
            foundEntities.forEach(function (entity) {
                if (entity.outbound.length > 0) {
                    if (entity.outbound[0].entityId == selectedSpecificationId) {
                        entitiesWithSelectedSpecification.push(entity);
                    }
                }
            });
            console.log("EntitiesWithSelectedSpecification:");
            console.log(entitiesWithSelectedSpecification);

            var validationResult = validateContents(entitiesWithSelectedSpecification, lines);
            if (validationResult.valid) {
                var failedEntityIds = [];

                var entityUpdateCount = 0;
                var totalEntities = validationResult.entitiesAndSpecificationsToUpdate.length;

                document.getElementById("totalItems").innerHTML = "Total entities to update: " + totalEntities;

                validationResult.entitiesAndSpecificationsToUpdate.forEach(function (entityAndSpecifications, index) {
                    var ajaxSettings = buildAjaxSettings("entities/" + entityAndSpecifications.entityId + "/specificationvalues");
                    ajaxSettings.type = "PUT";
                    ajaxSettings.data = JSON.stringify(entityAndSpecifications.specificationValuesForUpdate);
                    ajaxSettings.error = function (xhr) {
                        failedEntityIds.push(entityAndSpecifications.entityId);

                        showElement('importFailureRow');
                        var failedHtml = "Failed entity id(s): ";
                        var divider = "";
                        failedEntityIds.forEach(function (id, index) {
                            failedHtml += divider + id;
                            divider = ',';
                        });

                        document.getElementById("failed").innerHTML = failedHtml;
                    };
                    ajaxSettings.complete = function () {
                        entityUpdateCount++;
                        document.getElementById("progress").innerHTML = "Progress: " + Math.round(entityUpdateCount / totalEntities * 100) + " %";
                    }
                    $.ajax(ajaxSettings);
                });
            } else {
                showElement('importFailureRow');
                document.getElementById("validationFailures").innerHTML = validationResult.validationFailureHtml;
            }
        }

        function validateContents(entitiesWithSelectedSpecification, lines) {
            var result = {
                valid: true,
                validationFailureHtml: "",
                entitiesAndSpecificationsToUpdate: []
            };
            var headerVerification = verifyHeader(entitiesWithSelectedSpecification, lines[0], lines[1][0]);
            if (headerVerification.message.length == 0) {
                var skipHeader = true;
                lines.forEach(function (line, index) {
                    if (!skipHeader) {
                        var entityId = parseInt(line[0]);
                        var entity = entitiesWithSelectedSpecification.find(function (entity) {
                            return entity.entityId == entityId;
                        });

                        console.log("Row entity:");
                        console.log(entity);

                        var specificationName = specifications[selectedSpecificationId].specificationName;
                        if (entity !== undefined) {
                            var validationFailureListItems = "";
                            if (specificationName !== line[specificationNameColumnIndex]) {
                                validationFailureListItems += '<li>The ' + specificationMainNameField + ' column value <b>' + line[specificationNameColumnIndex] + '</b> does not match selected specification <b>' + specificationName + '</b></li>';
                            }

                            var entityAndSpecificationToUpdate = generateSpecificationValue(entityId, headerVerification.specificationFieldsMatchingHeader, line);
                            result.entitiesAndSpecificationsToUpdate.push(entityAndSpecificationToUpdate);
                            if (entityAndSpecificationToUpdate.validationFailures.length > 0) {
                                validationFailureListItems += _.map(entityAndSpecificationToUpdate.validationFailures,
                                    function (failure) {
                                        return '<li>' + failure + '</li>';
                                    }).join('');
                            }

                            if (validationFailureListItems.length > 0) {
                                result.validationFailureHtml += '<li>Entity ' + entityId + validationAdditionalEntityInformation(entity);
                                result.validationFailureHtml += '<ul>';
                                result.validationFailureHtml += validationFailureListItems;
                                result.validationFailureHtml += '</ul>';
                                result.validationFailureHtml += '</li>';
                            }
                        }
                    } else {
                        skipHeader = false;
                    }
                });

                console.log('entitiesAndSpecificationsToUpdate');
                console.log(result.entitiesAndSpecificationsToUpdate);
                console.log(result.validationFailureHtml);
            } else {
                result.validationFailureHtml += 'Imported file does not have a correct header. ' + headerVerification.message;
            }
            result.valid = result.validationFailureHtml.length === 0;
            return result;
        }

        function errorHandler(evt) {
            if (evt.target.error.name == "NotReadableError") {
                alert("Can not read file !");
            }
        }

        function validateCvlKeys(cvlKeys, cvlId) {
            var matchingCvl = allCvls.find(function (cvl) {
                return cvl.id === cvlId;
            });

            var result = [];
            cvlKeys.forEach(function (cvlKey) {
                var matchingCvlValue = matchingCvl.values.find(function (value) {
                    return value.key === cvlKey;
                });
                if (matchingCvlValue === undefined) {
                    result.push(cvlKey);
                }
            });
            return result.join(', ');
        }

        function createLocalString(cvlValue) {
            var localeString = new Object();
            allLanguages.forEach(function (lang) {
                localeString[lang.name] = cvlValue;
            });
            return localeString;
        }

        function generateSpecificationValue(entityId, specifications, line) {
            var checkAllCheckbox = document.getElementById('clearEmptyValues');
            var clearEmptyValues = checkAllCheckbox.checked;
            console.log("Clear empty values: " + clearEmptyValues);

            console.log("generateSpecificationValue:");
            console.log(specifications);

            var localeStringFields = new Object();
            var result = { entityId: entityId, specificationValuesForUpdate: [], validationFailures: [] };
            var valuePartLine = line.slice(predefinedColumns.length);

            console.log(valuePartLine);

            var specificationValue;
            for (var i = 0; i < valuePartLine.length; i++) {
                var skipValueIfLocaleString = false;

                specificationValue = new Object();
                specificationValue.specificationFieldTypeId = specifications[i].specificationField.id;

                if (valuePartLine[i].length === 0) {
                    console.log("LinePart value is empty: clearEmptyValue = " + clearEmptyValues);
                    if (clearEmptyValues) {
                        specificationValue.value = null;
                        result.specificationValuesForUpdate.push(specificationValue);
                    }
                    continue;
                }
                if (specifications[i].specificationField.dataType === "CVL") {
                    var cvlKeysToValidate = [];
                    if (specifications[i].specificationField.isMultiValue) {
                        specificationValue.value = valuePartLine[i].split(cvlSeparator);
                        cvlKeysToValidate = specificationValue.value;
                    } else {
                        specificationValue.value = valuePartLine[i];
                        cvlKeysToValidate.push(specificationValue.value);
                    }
                    var potentialErrorString = validateCvlKeys(cvlKeysToValidate, specifications[i].specificationField.cvlId);
                    if (potentialErrorString.length > 0) {
                        result.validationFailures.push("Column <b>" + specifications[i].specificationField.name[language] + "</b> of type <b>" + specifications[i].specificationField.dataType + "</b> has invalid values: <b>'" + potentialErrorString + "'</b>");
                    }
                } else if (specifications[i].specificationField.dataType === "LocaleString") {
                    if (localeStringFields[specifications[i].specificationField.id] === undefined) {
                        localeStringFields[specifications[i].specificationField.id] = new Object();
                    }
                    localeStringFields[specifications[i].specificationField.id][specifications[i].language] = valuePartLine[i];
                    skipValueIfLocaleString = true;
                } else if (specifications[i].specificationField.dataType === "Integer" ||
                    specifications[i].specificationField.dataType === "Double") {
                    specificationValue.value = Number(valuePartLine[i]);
                } else if (specifications[i].specificationField.dataType === "Boolean") {
                    specificationValue.value = valuePartLine[i].toLowerCase() === "true";
                } else {
                    specificationValue.value = valuePartLine[i];
                }

                var validationFunction = validations[specifications[i].specificationField.dataType];
                if (validationFunction !== undefined) {
                    if (!validationFunction(specificationValue.value)) {
                        var formatHint = specifications[i].specificationField.dataType === "DateTime" ? ". Format must follow ISO 8601 i.e. 'YYYY-MM-DDTHH:MM:SS.sZ'" : "";
                        result.validationFailures.push("Column <b>" + specifications[i].specificationField.name[language] + "</b> of type <b>" + specifications[i].specificationField.dataType + "</b> with value <b>'" + valuePartLine[i] + "'</b> is not valid" + formatHint);
                    }
                }

                if (!skipValueIfLocaleString) {
                    result.specificationValuesForUpdate.push(specificationValue);
                }
            }

            console.log('generateSpecificationValue(): localeStringFields');
            console.log(localeStringFields);

            for (var key in localeStringFields) {
                specificationValue = new Object();
                specificationValue.specificationFieldTypeId = key;
                specificationValue.value = localeStringFields[key];
                result.specificationValuesForUpdate.push(specificationValue);
                console.log(specificationValue);
            };

            console.log("generateSpecificationValue: result = ");
            console.log(result);

            return result;
        }

        function verifyHeader(entitiesWithSelectedSpecification, header, firstEntityId) {
            var entityId = parseInt(firstEntityId);
            var entity = entitiesWithSelectedSpecification.find(function (entity) {
                return entity.entityId == entityId;
            });

            console.log("verifyHeader: entityId = " + entityId + ", entity =");
            console.log(entity);

            var result = { message: "", specificationFieldsMatchingHeader: [] };

            if (entity === undefined) {
                result.message = "First entity with id " + entityId + " does not contain the selected specification: " + specifications[selectedSpecificationId].specificationName;
                return result;
            }

            if (header.length < predefinedColumns.length) {
                result.message = 'Header (and file) is not ' + csvDivider + '-separated';
                return result;
            }

            for (var i = 0; i < predefinedColumns.length; i++) {
                if (header[i] !== predefinedColumns[i].columnName(entity)) {
                    result.message = 'Column header number ' + (i + 1) + ' must have the name "' + predefinedColumns[i].columnName(entity) + '"';
                    return result;
                }
            }

            var specificationName = specifications[selectedSpecificationId].specificationName;
            for (var j = predefinedColumns.length; j < header.length; j++) {
                var specNameInHeaderParts = header[j].split('_');
                var specificationField = specificationFieldsArray.find(function (spec) {
                    return spec.name[language] === specNameInHeaderParts[0];
                });
                if (specificationField === undefined) {
                    result.message = 'Column "' + header[j] + '" is not part of the specification selected (= ' + specificationName + ')';
                } else {
                    var columnLanguage = "";
                    if (specNameInHeaderParts.length > 1) {
                        columnLanguage = specNameInHeaderParts[1];
                    }
                    result.specificationFieldsMatchingHeader.push({ specificationField: specificationField, language: columnLanguage });
                }
            }

            console.log('Header verification:');
            console.log(result);

            return result;
        }
    </script>

</head>
<body>
    <div class="container">
        <div class="row">
            <h1>Specification Import Export</h1>
        </div>
        <div class="row">
            <table class="table table-bordered">
                <thead class="thead-dark">
                    <tr>
                        <th scope="col">Step</th>
                        <th scope="col">Selection</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Workarea:</td>
                        <td id="workareaselection"></td>
                    </tr>
                    <tr id="specificationtemplaterow">
                        <td>Specification template:</td>
                        <td id="specificationtemplateselection"></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="tabs">
            <ul>
                <li><a href="#import">Import</a></li>
                <li><a href="#export">Export</a></li>
            </ul>
            <div id="import">
                <div class="row">
                    <div class="col-lg-4">
                        <div class="row">
                            <input type="file" id="doImport" accept=".csv,.xlsx" />
                        </div>
                        <div class="row">
                            <br/>
                            Clear empty values:&nbsp;&nbsp;
                            <input type="checkbox" id="clearEmptyValues"/>
                        </div>
                    </div>
                    <div class="col-lg-8">
                        <div class="row">
                            <div class="col-lg-4">
                                <p id="totalItems"></p>
                            </div>
                            <div class="col-lg-4">
                                <p id="progress"></p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-8">
                                <p class="failed"></p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row" id="importFailureRow">
                    <br />
                    <br />
                    <p class="failed" id="failed">Import failed:</p>
                    <ul id="validationFailures"></ul>
                </div>
            </div>
            <div id="export">
                <div class="row">
                    <table class="table table-bordered">
                        <tbody>
                            <tr id="fieldtyperow">
                                <td>Select fields:</td>
                                <td id="fieldtypeselection"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="row">
                    <div class="col-lg-2">
                        <button onclick="doExport()" class="btn btn-primary" id="doExport">Export</button>
                    </div>
                    <div class="col-lg-4">
                        File format:
                        <select name="exportFormatSelect">
                            <option value="xlsx" selected> XLSX</option>
                            <option value="csv"> CSV</option>
                        </select>
                    </div>
                    <div class="col-lg-4">
                        CSV separator:
                        <select name="csvDividerSelect" onchange="setCsvDivider()">
                            <option value="comma" selected=""> ,</option>
                            <option value="semicolon"> ;</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <br />
            <br />
            <br />
        </div>
    </div>
</body>
</html>